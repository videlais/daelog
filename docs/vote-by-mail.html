<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1">
        <meta charset="utf-8">
        <style>body {
  background-color: lightblue;
  margin: 0 auto;
  max-width: 800px;
  padding: 0 20px;
}
.container {
  border: 2px solid #dedede;
  background-color: #f1f1f1;
  border-radius: 5px;
  padding: 10px;
  margin: 10px 0;
}

.darker {
  border-color: #ccc;
  background-color: #ddd;
}

.container::after {
  content: "";
  clear: both;
  display: table;
}
</style>
		<title>Vote-By-Mail</title>
	</head>
	<body>
		<tw-storydata name="Vote-By-Mail" startnode="1" creator="Twine" creator-version="2.3.4" ifid="8FD060CD-ECE3-4BBE-96AB-1DC3B2C8D4FF" zoom="1" format="Dialog" format-version="0.4.0" options="" hidden><style role="stylesheet" id="twine-user-stylesheet" type="text/twine-css"></style><script role="script" id="twine-user-script" type="text/twine-javascript"></script><tw-passagedata pid="1" name="Start" tags="" position="675.5,44.5" size="100,100">&lt;include&gt;Setup&lt;/include&gt;
&lt;character name=&quot;Bot&quot;&gt;
	&lt;p&gt;Hi, there! It looks like this is your first time using the Vote-By-Text(TM) system.&lt;/p&gt;
	&lt;p&gt;The VbT(TM) is designed to help you cast your vote remotely, and from the safety of your home.&lt;/p&gt;
	&lt;p&gt;Text VOTE to vote or HISTORY for more details.&lt;/p&gt;
&lt;/character&gt;
&lt;character name=&quot;me&quot;&gt;&lt;p&gt;[[VOTE]]&lt;/p&gt;
	&lt;p&gt;[[HISTORY]]&lt;/p&gt;
&lt;/character&gt;

</tw-passagedata><tw-passagedata pid="2" name="VOTE" tags="" position="254.5,166.5" size="100,100">&lt;include&gt;Voting&lt;/include&gt;
&lt;character name=&quot;Bot&quot;&gt;
	&lt;p&gt;Are you ready to vote?&lt;/p&gt;
&lt;/character&gt;
&lt;character name=&quot;me&quot;&gt;
	&lt;p&gt;[[1 - $firstName$-&gt;1]]&lt;/p&gt;
	&lt;p&gt;[[2 - $secondName$-&gt;2]]&lt;/p&gt;
	&lt;p&gt;[[3 - $thirdName$-&gt;3]]&lt;/p&gt;
&lt;/character&gt;</tw-passagedata><tw-passagedata pid="3" name="Setup" tags="" position="903.5,96.5" size="100,100">&lt;script&gt;
	
	// Get the first name
	window.variables[&quot;firstName&quot;] = window.tracery.grammar.flatten(&quot;#name#&quot;);

	// Get the second name
	window.variables[&quot;secondName&quot;] = window.tracery.grammar.flatten(&quot;#name#&quot;);

	// Get the third name
	window.variables[&quot;thirdName&quot;] = window.tracery.grammar.flatten(&quot;#name#&quot;);
	
&lt;/script&gt;</tw-passagedata><tw-passagedata pid="4" name="name" tags="tracery" position="903.5,198.5" size="100,100">Tara,Lindsay,Beth,Audrey,Sam,Samantha,Victoria,Amy,Colleen,Diana,Tiffany,Margot,Caitlyn,Zoey,Becky,Jenny</tw-passagedata><tw-passagedata pid="5" name="HISTORY" tags="" position="400.5,401.5" size="100,100">&lt;character name=&quot;Bot&quot;&gt;
	&lt;p&gt;Established by Ordinance No. 43-2218, the Vote-By-Mail(TM) system replaces the existing lottery system. This works in connection with Ordinance No. 43-2208 that established procedures for eliminating overpopulation concerns. As a reminder, every voting adult must enroll in the lottery. Three names will be picked and one person must be removed from the community each year. The Lottery thanks you for following traditions.&lt;/p&gt;
	&lt;p&gt;Text VOTE to vote.&lt;/p&gt;
&lt;/character&gt;
&lt;character name=&quot;me&quot;&gt;&lt;p&gt;[[VOTE]]&lt;/p&gt;
&lt;/character&gt;</tw-passagedata><tw-passagedata pid="6" name="1" tags="" position="47.5,346.5" size="100,100">&lt;script&gt;
	// Filter out first name
	window.tracery.grammar.raw.name = window.tracery.grammar.raw.name.filter(function(value){ return value !==  window.variables[&quot;firstName&quot;] });
&lt;/script&gt;
&lt;character name=&quot;Bot&quot;&gt;
	&lt;p&gt;The Lottery thanks you for your vote.&lt;/p&gt;
	&lt;p&gt;Be sure to say goodbye to $secondName$ before she is removed from the community.&lt;/p&gt;
&lt;/character&gt;</tw-passagedata><tw-passagedata pid="7" name="2" tags="" position="218.5,339.5" size="100,100">&lt;script&gt;
	// Filter out second name
	window.tracery.grammar.raw.name = window.tracery.grammar.raw.name.filter(function(value){ return value !==  window.variables[&quot;secondName&quot;] });
&lt;/script&gt;
&lt;character name=&quot;Bot&quot;&gt;
	&lt;p&gt;The Lottery thanks you for your vote.&lt;/p&gt;
	&lt;p&gt;Be sure to say goodbye to $secondName$ before she is removed from the community.&lt;/p&gt;
&lt;/character&gt;</tw-passagedata><tw-passagedata pid="8" name="3" tags="" position="87.5,66.5" size="100,100">&lt;script&gt;
	// Filter out first name
	window.tracery.grammar.raw.name = window.tracery.grammar.raw.name.filter(function(value){ return value !==  window.variables[&quot;thirdName&quot;] });
&lt;/script&gt;
&lt;character name=&quot;Bot&quot;&gt;
	&lt;p&gt;The Lottery thanks you for your vote.&lt;/p&gt;
	&lt;p&gt;Be sure to say goodbye to $thirdName$ before she is removed from the community.&lt;/p&gt;
&lt;/character&gt;
</tw-passagedata><tw-passagedata pid="9" name="RESTART" tags="" position="701.5,197.5" size="100,100">&lt;include&gt;Setup&lt;/include&gt;
&lt;character name=&quot;me&quot;&gt;
	&lt;p&gt;[[VOTE]]&lt;/p&gt;
	&lt;p&gt;[[HISTORY]]&lt;/p&gt;
&lt;/character&gt;</tw-passagedata><tw-passagedata pid="10" name="Begin" tags="" position="410,34.5" size="100,100">&lt;character name=&quot;Bot&quot;&gt;
	&lt;p&gt;Hi, there! It looks like this is your first time using the Vote-By-Text(TM) system.&lt;/p&gt;
	&lt;p&gt;The VbT(TM) is designed to help you cast your vote remotely and from the safety of your home during this of uncertainty.&lt;/p&gt;
	&lt;p&gt;Text VOTE to vote or HISTORY for more details.&lt;/p&gt;
&lt;/character&gt;
&lt;character name=&quot;me&quot;&gt;&lt;p&gt;[[VOTE]]&lt;/p&gt;
	&lt;p&gt;[[HISTORY]]&lt;/p&gt;
&lt;/character&gt;</tw-passagedata></tw-storydata>
		<script>
        (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/**
 * @author Kate
 */

var tracery = function() {

    var TraceryNode = function(parent, childIndex, settings) {
        this.errors = [];

        // No input? Add an error, but continue anyways
        if (settings.raw === undefined) {
            this.errors.push("Empty input for node");
            settings.raw = "";
        }

        // If the root node of an expansion, it will have the grammar passed as the 'parent'
        //  set the grammar from the 'parent', and set all other values for a root node
        if ( parent instanceof tracery.Grammar) {
            this.grammar = parent;
            this.parent = null;
            this.depth = 0;
            this.childIndex = 0;
        } else {
            this.grammar = parent.grammar;
            this.parent = parent;
            this.depth = parent.depth + 1;
            this.childIndex = childIndex;
        }

        this.raw = settings.raw;
        this.type = settings.type;
        this.isExpanded = false;

        if (!this.grammar) {
            this.errors.push("No grammar specified for this node " + this);
        }

    };

    TraceryNode.prototype.toString = function() {
        return "Node('" + this.raw + "' " + this.type + " d:" + this.depth + ")";
    };

    // Expand the node (with the given child rule)
    //  Make children if the node has any
    TraceryNode.prototype.expandChildren = function(childRule, preventRecursion) {
        this.children = [];
        this.finishedText = "";

        // Set the rule for making children,
        // and expand it into section
        this.childRule = childRule;
        if (this.childRule !== undefined) {
            var sections = tracery.parse(childRule);

            // Add errors to this
            if (sections.errors.length > 0) {
                this.errors = this.errors.concat(sections.errors);

            }

            for (var i = 0; i < sections.length; i++) {
                this.children[i] = new TraceryNode(this, i, sections[i]);
                if (!preventRecursion)
                    this.children[i].expand(preventRecursion);

                // Add in the finished text
                this.finishedText += this.children[i].finishedText;
            }
        } else {
            // In normal operation, this shouldn't ever happen
            this.errors.push("No child rule provided, can't expand children");
        }
    };

    // Expand this rule (possibly creating children)
    TraceryNode.prototype.expand = function(preventRecursion) {

        if (!this.isExpanded) {
            this.isExpanded = true;

            this.expansionErrors = [];

            // Types of nodes
            // -1: raw, needs parsing
            //  0: Plaintext
            //  1: Tag ("#symbol.mod.mod2.mod3#" or "#[pushTarget:pushRule]symbol.mod")
            //  2: Action ("[pushTarget:pushRule], [pushTarget:POP]", more in the future)

            switch(this.type) {
            // Raw rule
            case -1:

                this.expandChildren(this.raw, preventRecursion);
                break;

            // plaintext, do nothing but copy text into finsihed text
            case 0:
                this.finishedText = this.raw;
                break;

            // Tag
            case 1:
                // Parse to find any actions, and figure out what the symbol is
                this.preactions = [];
                this.postactions = [];

                var parsed = tracery.parseTag(this.raw);

                // Break into symbol actions and modifiers
                this.symbol = parsed.symbol;
                this.modifiers = parsed.modifiers;

                // Create all the preactions from the raw syntax
                for (var i = 0; i < parsed.preactions.length; i++) {
                    this.preactions[i] = new NodeAction(this, parsed.preactions[i].raw);
                }
                for (var i = 0; i < parsed.postactions.length; i++) {
                    //   this.postactions[i] = new NodeAction(this, parsed.postactions[i].raw);
                }

                // Make undo actions for all preactions (pops for each push)
                for (var i = 0; i < this.preactions.length; i++) {
                    if (this.preactions[i].type === 0)
                        this.postactions.push(this.preactions[i].createUndo());
                }

                // Activate all the preactions
                for (var i = 0; i < this.preactions.length; i++) {
                    this.preactions[i].activate();
                }

                this.finishedText = this.raw;

                // Expand (passing the node, this allows tracking of recursion depth)

                var selectedRule = this.grammar.selectRule(this.symbol, this, this.errors);

                this.expandChildren(selectedRule, preventRecursion);

                // Apply modifiers
                // TODO: Update parse function to not trigger on hashtags within parenthesis within tags,
                //   so that modifier parameters can contain tags "#story.replace(#protagonist#, #newCharacter#)#"
                for (var i = 0; i < this.modifiers.length; i++) {
                    var modName = this.modifiers[i];
                    var modParams = [];
                    if (modName.indexOf("(") > 0) {
                        var regExp = /\(([^)]+)\)/;

                        // Todo: ignore any escaped commas.  For now, commas always split
                        var results = regExp.exec(this.modifiers[i]);
                        if (!results || results.length < 2) {
                        } else {
                            var modParams = results[1].split(",");
                            modName = this.modifiers[i].substring(0, modName.indexOf("("));
                        }

                    }

                    var mod = this.grammar.modifiers[modName];

                    // Missing modifier?
                    if (!mod) {
                        this.errors.push("Missing modifier " + modName);
                        this.finishedText += "((." + modName + "))";
                    } else {
                        this.finishedText = mod(this.finishedText, modParams);

                    }

                }

                // Perform post-actions
                for (var i = 0; i < this.postactions.length; i++) {
                    this.postactions[i].activate();
                }
                break;
            case 2:

                // Just a bare action?  Expand it!
                this.action = new NodeAction(this, this.raw);
                this.action.activate();

                // No visible text for an action
                // TODO: some visible text for if there is a failure to perform the action?
                this.finishedText = "";
                break;

            }

        } else {
            //console.warn("Already expanded " + this);
        }

    };

    TraceryNode.prototype.clearEscapeChars = function() {

        this.finishedText = this.finishedText.replace(/\\\\/g, "DOUBLEBACKSLASH").replace(/\\/g, "").replace(/DOUBLEBACKSLASH/g, "\\");
    };

    // An action that occurs when a node is expanded
    // Types of actions:
    // 0 Push: [key:rule]
    // 1 Pop: [key:POP]
    // 2 function: [functionName(param0,param1)] (TODO!)
    function NodeAction(node, raw) {
        /*
         if (!node)
         console.warn("No node for NodeAction");
         if (!raw)
         console.warn("No raw commands for NodeAction");
         */

        this.node = node;

        var sections = raw.split(":");
        this.target = sections[0];

        // No colon? A function!
        if (sections.length === 1) {
            this.type = 2;

        }

        // Colon? It's either a push or a pop
        else {
            this.rule = sections[1];
            if (this.rule === "POP") {
                this.type = 1;
            } else {
                this.type = 0;
            }
        }
    }


    NodeAction.prototype.createUndo = function() {
        if (this.type === 0) {
            return new NodeAction(this.node, this.target + ":POP");
        }
        // TODO Not sure how to make Undo actions for functions or POPs
        return null;
    };

    NodeAction.prototype.activate = function() {
        var grammar = this.node.grammar;
        switch(this.type) {
        case 0:
            // split into sections (the way to denote an array of rules)
            this.ruleSections = this.rule.split(",");
            this.finishedRules = [];
            this.ruleNodes = [];
            for (var i = 0; i < this.ruleSections.length; i++) {
                var n = new TraceryNode(grammar, 0, {
                    type : -1,
                    raw : this.ruleSections[i]
                });

                n.expand();

                this.finishedRules.push(n.finishedText);
            }

            // TODO: escape commas properly
            grammar.pushRules(this.target, this.finishedRules, this);
            break;
        case 1:
            grammar.popRules(this.target);
            break;
        case 2:
            grammar.flatten(this.target, true);
            break;
        }

    };

    NodeAction.prototype.toText = function() {
        switch(this.type) {
        case 0:
            return this.target + ":" + this.rule;
        case 1:
            return this.target + ":POP";
        case 2:
            return "((some function))";
        default:
            return "((Unknown Action))";
        }
    };

    // Sets of rules
    // Can also contain conditional or fallback sets of rulesets)
    function RuleSet(grammar, raw) {
        this.raw = raw;
        this.grammar = grammar;
        this.falloff = 1;

        if (Array.isArray(raw)) {
            this.defaultRules = raw;
        } else if ( typeof raw === 'string' || raw instanceof String) {
            this.defaultRules = [raw];
        } else if (raw === 'object') {
            // TODO: support for conditional and hierarchical rule sets
        }

    };

    RuleSet.prototype.selectRule = function(errors) {
        // console.log("Get rule", this.raw);
        // Is there a conditional?
        if (this.conditionalRule) {
            var value = this.grammar.expand(this.conditionalRule, true);
            // does this value match any of the conditionals?
            if (this.conditionalValues[value]) {
                var v = this.conditionalValues[value].selectRule(errors);
                if (v !== null && v !== undefined)
                    return v;
            }
            // No returned value?
        }

        // Is there a ranked order?
        if (this.ranking) {
            for (var i = 0; i < this.ranking.length; i++) {
                var v = this.ranking.selectRule();
                if (v !== null && v !== undefined)
                    return v;
            }

            // Still no returned value?
        }

        if (this.defaultRules !== undefined) {
            var index = 0;
            // Select from this basic array of rules

            // Get the distribution from the grammar if there is no other
            var distribution = this.distribution;
            if (!distribution)
                distribution = this.grammar.distribution;

            switch(distribution) {
            case "shuffle":

                // create a shuffle desk
                if (!this.shuffledDeck || this.shuffledDeck.length === 0) {
                    // make an array
                    this.shuffledDeck = fyshuffle(Array.apply(null, {
                        length : this.defaultRules.length
                    }).map(Number.call, Number), this.falloff);

                }

                index = this.shuffledDeck.pop();

                break;
            case "weighted":
                errors.push("Weighted distribution not yet implemented");
                break;
            case "falloff":
                errors.push("Falloff distribution not yet implemented");
                break;
            default:

                index = Math.floor(Math.pow(Math.random(), this.falloff) * this.defaultRules.length);
                break;
            }

            if (!this.defaultUses)
                this.defaultUses = [];
            this.defaultUses[index] = ++this.defaultUses[index] || 1;
            return this.defaultRules[index];
        }

        errors.push("No default rules defined for " + this);
        return null;

    };

    RuleSet.prototype.clearState = function() {

        if (this.defaultUses) {
            this.defaultUses = [];
        }
    };

    function fyshuffle(array, falloff) {
        var currentIndex = array.length,
            temporaryValue,
            randomIndex;

        // While there remain elements to shuffle...
        while (0 !== currentIndex) {

            // Pick a remaining element...
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex -= 1;

            // And swap it with the current element.
            temporaryValue = array[currentIndex];
            array[currentIndex] = array[randomIndex];
            array[randomIndex] = temporaryValue;
        }

        return array;
    }

    var Symbol = function(grammar, key, rawRules) {
        // Symbols can be made with a single value, and array, or array of objects of (conditions/values)
        this.key = key;
        this.grammar = grammar;
        this.rawRules = rawRules;

        this.baseRules = new RuleSet(this.grammar, rawRules);
        this.clearState();

    };

    Symbol.prototype.clearState = function() {

        // Clear the stack and clear all ruleset usages
        this.stack = [this.baseRules];

        this.uses = [];
        this.baseRules.clearState();
    };

    Symbol.prototype.pushRules = function(rawRules) {
        var rules = new RuleSet(this.grammar, rawRules);
        this.stack.push(rules);
    };

    Symbol.prototype.popRules = function() {
        this.stack.pop();
    };

    Symbol.prototype.selectRule = function(node, errors) {
        this.uses.push({
            node : node
        });

        if (this.stack.length === 0) {
            errors.push("The rule stack for '" + this.key + "' is empty, too many pops?");
            return "((" + this.key + "))";
        }

        return this.stack[this.stack.length - 1].selectRule();
    };

    Symbol.prototype.getActiveRules = function() {
        if (this.stack.length === 0) {
            return null;
        }
        return this.stack[this.stack.length - 1].selectRule();
    };

    Symbol.prototype.rulesToJSON = function() {
        return JSON.stringify(this.rawRules);
    };

    var Grammar = function(raw, settings) {
        this.modifiers = {};
        this.loadFromRawObj(raw);
    };

    Grammar.prototype.clearState = function() {
        var keys = Object.keys(this.symbols);
        for (var i = 0; i < keys.length; i++) {
            this.symbols[keys[i]].clearState();
        }
    };

    Grammar.prototype.addModifiers = function(mods) {

        // copy over the base modifiers
        for (var key in mods) {
            if (mods.hasOwnProperty(key)) {
                this.modifiers[key] = mods[key];
            }
        };

    };

    Grammar.prototype.loadFromRawObj = function(raw) {

        this.raw = raw;
        this.symbols = {};
        this.subgrammars = [];

        if (this.raw) {
            // Add all rules to the grammar
            for (var key in this.raw) {
                if (this.raw.hasOwnProperty(key)) {
                    this.symbols[key] = new Symbol(this, key, this.raw[key]);
                }
            }
        }
    };

    Grammar.prototype.createRoot = function(rule) {
        // Create a node and subnodes
        var root = new TraceryNode(this, 0, {
            type : -1,
            raw : rule,
        });

        return root;
    };

    Grammar.prototype.expand = function(rule, allowEscapeChars) {
        var root = this.createRoot(rule);
        root.expand();
        if (!allowEscapeChars)
            root.clearEscapeChars();

        return root;
    };

    Grammar.prototype.flatten = function(rule, allowEscapeChars) {
        var root = this.expand(rule, allowEscapeChars);

        return root.finishedText;
    };

    Grammar.prototype.toJSON = function() {
        var keys = Object.keys(this.symbols);
        var symbolJSON = [];
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            symbolJSON.push(' "' + key + '" : ' + this.symbols[key].rulesToJSON());
        }
        return "{\n" + symbolJSON.join(",\n") + "\n}";
    };

    // Create or push rules
    Grammar.prototype.pushRules = function(key, rawRules, sourceAction) {

        if (this.symbols[key] === undefined) {
            this.symbols[key] = new Symbol(this, key, rawRules);
            if (sourceAction)
                this.symbols[key].isDynamic = true;
        } else {
            this.symbols[key].pushRules(rawRules);
        }
    };

    Grammar.prototype.popRules = function(key) {
        if (!this.symbols[key])
            this.errors.push("Can't pop: no symbol for key " + key);
        this.symbols[key].popRules();
    };

    Grammar.prototype.selectRule = function(key, node, errors) {
        if (this.symbols[key]) {
            var rule = this.symbols[key].selectRule(node, errors);

            return rule;
        }

        // Failover to alternative subgrammars
        for (var i = 0; i < this.subgrammars.length; i++) {

            if (this.subgrammars[i].symbols[key])
                return this.subgrammars[i].symbols[key].selectRule();
        }

        // No symbol?
        errors.push("No symbol for '" + key + "'");
        return "((" + key + "))";
    };

    // Parses a plaintext rule in the tracery syntax
    tracery = {

        createGrammar : function(raw) {
            return new Grammar(raw);
        },

        // Parse the contents of a tag
        parseTag : function(tagContents) {

            var parsed = {
                symbol : undefined,
                preactions : [],
                postactions : [],
                modifiers : []
            };
            var sections = tracery.parse(tagContents);
            var symbolSection = undefined;
            for (var i = 0; i < sections.length; i++) {
                if (sections[i].type === 0) {
                    if (symbolSection === undefined) {
                        symbolSection = sections[i].raw;
                    } else {
                        throw ("multiple main sections in " + tagContents);
                    }
                } else {
                    parsed.preactions.push(sections[i]);
                }
            }

            if (symbolSection === undefined) {
                //   throw ("no main section in " + tagContents);
            } else {
                var components = symbolSection.split(".");
                parsed.symbol = components[0];
                parsed.modifiers = components.slice(1);
            }
            return parsed;
        },

        parse : function(rule) {
            var depth = 0;
            var inTag = false;
            var sections = [];
            var escaped = false;

            var errors = [];
            var start = 0;

            var escapedSubstring = "";
            var lastEscapedChar = undefined;

            if (rule === null) {
                var sections = [];
                sections.errors = errors;

                return sections;
            }

            function createSection(start, end, type) {
                if (end - start < 1) {
                    if (type === 1)
                        errors.push(start + ": empty tag");
                    if (type === 2)
                        errors.push(start + ": empty action");

                }
                var rawSubstring;
                if (lastEscapedChar !== undefined) {
                    rawSubstring = escapedSubstring + "\\" + rule.substring(lastEscapedChar + 1, end);

                } else {
                    rawSubstring = rule.substring(start, end);
                }
                sections.push({
                    type : type,
                    raw : rawSubstring
                });
                lastEscapedChar = undefined;
                escapedSubstring = "";
            };

            for (var i = 0; i < rule.length; i++) {

                if (!escaped) {
                    var c = rule.charAt(i);

                    switch(c) {

                    // Enter a deeper bracketed section
                    case '[':
                        if (depth === 0 && !inTag) {
                            if (start < i)
                                createSection(start, i, 0);
                            start = i + 1;
                        }
                        depth++;
                        break;

                    case ']':
                        depth--;

                        // End a bracketed section
                        if (depth === 0 && !inTag) {
                            createSection(start, i, 2);
                            start = i + 1;
                        }
                        break;

                    // Hashtag
                    //   ignore if not at depth 0, that means we are in a bracket
                    case '#':
                        if (depth === 0) {
                            if (inTag) {
                                createSection(start, i, 1);
                                start = i + 1;
                            } else {
                                if (start < i)
                                    createSection(start, i, 0);
                                start = i + 1;
                            }
                            inTag = !inTag;
                        }
                        break;

                    case '\\':
                        escaped = true;
                        escapedSubstring = escapedSubstring + rule.substring(start, i);
                        start = i + 1;
                        lastEscapedChar = i;
                        break;
                    }
                } else {
                    escaped = false;
                }
            }
            if (start < rule.length)
                createSection(start, rule.length, 0);

            if (inTag) {
                errors.push("Unclosed tag");
            }
            if (depth > 0) {
                errors.push("Too many [");
            }
            if (depth < 0) {
                errors.push("Too many ]");
            }

            // Strip out empty plaintext sections

            sections = sections.filter(function(section) {
                if (section.type === 0 && section.raw.length === 0)
                    return false;
                return true;
            });
            sections.errors = errors;
            return sections;
        },
    };

    function isVowel(c) {
        var c2 = c.toLowerCase();
        return (c2 === 'a') || (c2 === 'e') || (c2 === 'i') || (c2 === 'o') || (c2 === 'u');
    };

    function isAlphaNum(c) {
        return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9');
    };
    function escapeRegExp(str) {
        return str.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
    }

    var baseEngModifiers = {

        replace : function(s, params) {
            //http://stackoverflow.com/questions/1144783/replacing-all-occurrences-of-a-string-in-javascript
            return s.replace(new RegExp(escapeRegExp(params[0]), 'g'), params[1]);
        },

        capitalizeAll : function(s) {
            var s2 = "";
            var capNext = true;
            for (var i = 0; i < s.length; i++) {

                if (!isAlphaNum(s.charAt(i))) {
                    capNext = true;
                    s2 += s.charAt(i);
                } else {
                    if (!capNext) {
                        s2 += s.charAt(i);
                    } else {
                        s2 += s.charAt(i).toUpperCase();
                        capNext = false;
                    }

                }
            }
            return s2;
        },

        capitalize : function(s) {
            return s.charAt(0).toUpperCase() + s.substring(1);
        },

        a : function(s) {
            if (s.length > 0) {
                if (s.charAt(0).toLowerCase() === 'u') {
                    if (s.length > 2) {
                        if (s.charAt(2).toLowerCase() === 'i')
                            return "a " + s;
                    }
                }

                if (isVowel(s.charAt(0))) {
                    return "an " + s;
                }
            }

            return "a " + s;

        },

        firstS : function(s) {
            console.log(s);
            var s2 = s.split(" ");

            var finished = baseEngModifiers.s(s2[0]) + " " + s2.slice(1).join(" ");
            console.log(finished);
            return finished;
        },

        s : function(s) {
            switch (s.charAt(s.length -1)) {
            case 's':
                return s + "es";
                break;
            case 'h':
                return s + "es";
                break;
            case 'x':
                return s + "es";
                break;
            case 'y':
                if (!isVowel(s.charAt(s.length - 2)))
                    return s.substring(0, s.length - 1) + "ies";
                else
                    return s + "s";
                break;
            default:
                return s + "s";
            }
        },
        ed : function(s) {
            switch (s.charAt(s.length -1)) {
            case 's':
                return s + "ed";
                break;
            case 'e':
                return s + "d";
                break;
            case 'h':
                return s + "ed";
                break;
            case 'x':
                return s + "ed";
                break;
            case 'y':
                if (!isVowel(s.charAt(s.length - 2)))
                    return s.substring(0, s.length - 1) + "ied";
                else
                    return s + "d";
                break;
            default:
                return s + "ed";
            }
        }
    };

    tracery.baseEngModifiers = baseEngModifiers; 
    // Externalize
    tracery.TraceryNode = TraceryNode;

    tracery.Grammar = Grammar;
    tracery.Symbol = Symbol;
    tracery.RuleSet = RuleSet;
    return tracery;
}();

module.exports = tracery; 
},{}],2:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports["default"]=void 0;function _createForOfIteratorHelper(a){if("undefined"==typeof Symbol||null==a[Symbol.iterator]){if(Array.isArray(a)||(a=_unsupportedIterableToArray(a))){var b=0,c=function(){};return{s:c,n:function n(){return b>=a.length?{done:!0}:{done:!1,value:a[b++]}},e:function e(a){throw a},f:c}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var d,e,f=!0,g=!1;return{s:function s(){d=a[Symbol.iterator]()},n:function n(){var a=d.next();return f=a.done,a},e:function e(a){g=!0,e=a},f:function f(){try{f||null==d["return"]||d["return"]()}finally{if(g)throw e}}}}function _unsupportedIterableToArray(a,b){if(a){if("string"==typeof a)return _arrayLikeToArray(a,b);var c=Object.prototype.toString.call(a).slice(8,-1);return"Object"===c&&a.constructor&&(c=a.constructor.name),"Map"===c||"Set"===c?Array.from(c):"Arguments"===c||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(c)?_arrayLikeToArray(a,b):void 0}}function _arrayLikeToArray(a,b){(null==b||b>a.length)&&(b=a.length);for(var c=0,d=Array(b);c<b;c++)d[c]=a[c];return d}function _classCallCheck(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function _defineProperties(a,b){for(var c,d=0;d<b.length;d++)c=b[d],c.enumerable=c.enumerable||!1,c.configurable=!0,"value"in c&&(c.writable=!0),Object.defineProperty(a,c.key,c)}function _createClass(a,b,c){return b&&_defineProperties(a.prototype,b),c&&_defineProperties(a,c),a}var Dialog=/*#__PURE__*/function(){function Dialog(){_classCallCheck(this,Dialog);for(var a,b=document.querySelector("tw-storydata"),c=b.attributes.startnode.value,d=this.findPassageByPid(c),e=document.querySelectorAll("tw-passagedata"),f={},g=0;g<e.length;g++)if(a=e[g],a.hasAttribute("tags")&&a.attributes.tags.value.includes("tracery")){var h=a.attributes.name.value,j=a.innerHTML.split(",");f[h]=j}window.tracery.grammar=window.tracery.createGrammar(f),this.showPassage(d)}return _createClass(Dialog,[{key:"findPassageByPid",value:function findPassageByPid(a){// Find the element by its 'pid'
return document.querySelector("[pid=\"".concat(a,"\"]"))}},{key:"findPassageByName",value:function findPassageByName(a){// Find the element by its 'name'
return document.querySelector("[name=\"".concat(a,"\"]"))}},{key:"showPassage",value:function showPassage(a){// Look for the 'tw-passage'
var b=document.querySelector("tw-passage");// If it is null, it does not exist yet
null===b&&(b=document.createElement("tw-passage"));// Save the passage contents
var c=a.innerHTML;// Parse contents
c=this.parse(c),b.innerHTML+=c;// Find all links in the current passage
var d,e=b.querySelectorAll("a[data-passage]"),f=_createForOfIteratorHelper(e);// For each link, add an event listener
try{for(f.s();!(d=f.n()).done;){var g=d.value;g.addEventListener("click",function(a){// Get the name of the passage to load.
var b=this.attributes["data-passage"].value,c=window.dialog.findPassageByName(b),d=a.target.textContent,e=document.querySelector(".choices");// Find the passage by its name
e.innerHTML=d,e.className="",window.dialog.showPassage(c)})}// Append the child element to the HTML <body>
// (If it already exists, it will not be appended.)
}catch(a){f.e(a)}finally{f.f()}document.body.appendChild(b)}},{key:"parse",value:function parse(result){var _this=this;result=result.replace(/&lt;/g,function(){return"<"}),result=result.replace(/&gt;/g,function(){return">"}),result=result.replace(/<script>((?:.|\n)*?)<\/script>/g,function(match,target){// Run the code
try{eval(target)}catch(a){console.log(a)}// Return an empty string
return""}),result=result.replace(/\n/g,function(){return"<br>"}),result=result.replace(/\#(.*?)\#/g,function(a){return window.tracery.grammar.flatten(a)}),result=result.replace(/\$(.*?)\$/g,function(a,b){var c="";return window.variables.hasOwnProperty(b)&&(c=window.variables[b]),c}),result=result.replace(/<include>(.*?)<\/include>/g,function(a,b){// Look for the passage by its name
var c=_this.findPassageByName(b),d="";// Save a result
// Return result.
// It will either be an empty string or the parsed content.
return null!==c&&(d=_this.parse(c.innerHTML)),d}),result=result.replace(/\[\[(.*?)\]\]/g,function(a,b){var c=b,d=b.indexOf("|");/* display|target format */if(-1!==d)c=b.substr(0,d),b=b.substr(d+1);else{/* display->target format */var e=b.indexOf("->");if(-1!==e)c=b.substr(0,e),b=b.substr(e+2);else{/* target<-display format */var f=b.indexOf("<-");-1!==f&&(c=b.substr(f+2),b=b.substr(0,f))}}return"<a href=\"javascript:void(0)\" data-passage=\""+b+"\">"+c+"</a>"});// Create a DocumentFragment
var fragment=new DocumentFragment,body=document.createElement("body");// Create a BODY
body.innerHTML=result,fragment.append(body);var _step2,dialog="",originalLinks=fragment.querySelectorAll("a"),newLinks=[],_iterator2=_createForOfIteratorHelper(originalLinks);try{// Clone the previous links into a new array
for(_iterator2.s();!(_step2=_iterator2.n()).done;){var l=_step2.value;newLinks.push(l.cloneNode(!0)),l.remove()}// Find all CHARACTER elements
}catch(a){_iterator2.e(a)}finally{_iterator2.f()}var _step3,characters=fragment.querySelectorAll("character"),_iterator3=_createForOfIteratorHelper(characters);try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var _char=_step3.value,name=_char.attributes.name.value,textContent=_char.textContent;if("me"===name){dialog+="\n              <div class=\"container darker\">\n                  <p>".concat(textContent,"</p>\n                  <div class=\"choices\">");var _step4,_iterator4=_createForOfIteratorHelper(newLinks);try{for(_iterator4.s();!(_step4=_iterator4.n()).done;){var _l=_step4.value;dialog+="\n                          ".concat(_l.outerHTML,"\n                          <br>\n                          ")}}catch(a){_iterator4.e(a)}finally{_iterator4.f()}dialog+="</div>\n              </div>"}else dialog+="\n              <div class=\"container\">\n                  <p><strong>".concat(name,"</strong>: ").concat(textContent,"</p>\n              </div>");_char.remove()}}catch(a){_iterator3.e(a)}finally{_iterator3.f()}return result+=dialog,result=result.replace(/<character(.*?)>(.*?)<\/character>/g,function(){// Return an empty string
return""}),result}}]),Dialog}(),_default=Dialog;exports["default"]=_default;

},{}],3:[function(require,module,exports){
"use strict";var _traceryGrammar=_interopRequireDefault(require("tracery-grammar")),_Dialog=_interopRequireDefault(require("./Dialog.js"));function _interopRequireDefault(a){return a&&a.__esModule?a:{default:a}}window.tracery=_traceryGrammar["default"],window.variables={},window.dialog=new _Dialog["default"];

},{"./Dialog.js":2,"tracery-grammar":1}]},{},[3]);

		</script>
	</body>
</html>
